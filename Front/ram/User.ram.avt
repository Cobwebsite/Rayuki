import { UserRouter } from "../generated/Routes/UserRouter.lib.avt";
import { User } from "../generated/Data/User.data.avt";
import { HttpRouter } from "../libs/HttpRouter.lib.avt";
import { RamHttp } from "./RamWithTransaction.lib.avt";

namespace RAM {
    interface UserMethod {
        // define your methods here
    }

    export type UserExtended = User & UserMethod;

    export class UserRAM extends RamHttp<UserExtended> implements Aventus.IRam {

        private connectedUserId?: number;

        /**
         * Create a singleton to store data
         */
        public static getInstance(): UserRAM {
            return Aventus.Instance.get(UserRAM);
        }

        /**
         * @inheritdoc
         */
        public override defineIndexKey(): keyof UserExtended {
            return 'Id';
        }
        /**
         * @inheritdoc
         */
        protected override getTypeForData(objJson: Aventus.KeysObject<UserExtended> | UserExtended): new () => UserExtended {
            return this.addUserMethod(User);
        }

        /**
         * @inheritdoc
         */
        public override defineRoutes() {
            return new UserRouter(new HttpRouter());
        }

        public async getConnected(): Promise<Aventus.ResultWithError<Aventus.RamItem<UserExtended>>> {
            return this.actionGuard.run(["getConnected"], async () => {
                let result: Aventus.ResultWithError<Aventus.RamItem<UserExtended>> = new Aventus.ResultWithError();
                if(!this.connectedUserId) {
                    let query = await new UserRouter().GetConnected();
                    if(!query.success || !query.result) {
                        result.errors = query.errors;
                        return result;
                    }
                    this.connectedUserId = query.result.Id;
                    this.addOrUpdateData(query.result, result);
                    if(!result.success) {
                        return result;
                    }
                }
                return this.getByIdWithError(this.connectedUserId);
            })
        }

        /**
         * Mixin pattern to add methods
         */
        private addUserMethod<B extends (new (...args: any[]) => User) & { className?: string; }>(Base: B) {
            return class Extension extends Base implements UserExtended {

                public static override get className(): string {
                    return Base.className || Base.name;
                }
                public override get className(): string {
                    return Base.className || Base.name;
                }

                // code your methods here
            };
        }

    }
}