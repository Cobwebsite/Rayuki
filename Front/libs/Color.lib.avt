import { Colors } from "./Colors.lib.avt";

namespace Lib {
    export type RGBColor = {
        r: number,
        g: number,
        b: number;
    };
    export type RGBAColor = {
        r: number,
        g: number,
        b: number,
        a: number;
    };
    export type HSLColor = {
        h: number,
        s: number,
        l: number;
    };
    export type HSLAColor = {
        h: number,
        s: number,
        l: number;
        a: number;
    };
    export type HSVColor = {
        h: number,
        s: number,
        v: number;
    };

    export type HSVAColor = {
        h: number,
        s: number,
        v: number;
        a: number;
    };
    export class Color {

        public static isValid(txt: string) {
            return this.getColorType(txt) != -1;
        }
        private static types: {
            rgb: "rgb",
            hex: "hex",
            rgba: "rgba",
            hsl: "hsl",
            hsla: "hsla",
            hsv: "hsv",
            hsva: "hsva",
            static: "static";
        } = {
                rgb: "rgb",
                hex: "hex",
                rgba: "rgba",
                hsl: "hsl",
                hsla: "hsla",
                hsv: "hsv",
                hsva: "hsva",
                static: "static"
            };

        private static getColorType(colorString: string) {
            let treatedColor = colorString.replaceAll(" ", "");
            if(
                /^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i.test(treatedColor) ||
                /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.test(treatedColor)
            ) {
                return Color.types.hex;
            } else if(/^rgba?\((\d{1,3},*){3,4}\)$/.test(treatedColor)) {
                return treatedColor.startsWith("rgba") ? Color.types.rgba : Color.types.rgb;
            } else if(/^hsla?\(\s*(\d{1,3})\s*(,| )\s*(\d{1,3})%?\s*(,| )\s*(\d{1,3})%?\s*(,\s*(0|1|0?\.\d+)\s*)?\)$/.test(treatedColor)) {
                return treatedColor.startsWith("hsla") ? Color.types.hsla : Color.types.hsl;
            } else if(/^hsva?\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*(,\s*(0|1|0?\.\d+))?\s*\)$/.test(treatedColor)) {
                return treatedColor.startsWith("hsva") ? Color.types.hsva : Color.types.hsv;
            } else if(Object.hasOwn(Colors, colorString.toUpperCase())) {
                return Color.types.static;
            }
            else {
                return -1;
            }
        }
        public static createFromRgb(r: number, g: number, b: number) {
            return new Color(`rgb(${r},${g},${b})`);
        }
        public static createFromHsl(h: number, s: number, l: number) {
            return new Color(`hsl(${h},${s}%,${l}%)`);
        }
        public static createFromRgba(r: number, g: number, b: number, a: number) {
            return new Color(`rgba(${r},${g},${b},${a})`);
        }
        public static createFromHsla(h: number, s: number, l: number, a: number) {
            return new Color(`hsla(${h},${s}%,${l}%,${a})`);
        }
        public static createFromHsvla(h: number, s: number, v: number, a: number) {
            return new Color(`hsva(${h},${s}%,${v}%,${a})`);
        }

        private _watcher: any;
        private get currentColor(): RGBAColor {
            return this._watcher.currentColor;
        }
        private set currentColor(value: RGBAColor) {
            this._watcher.currentColor = value;
        }


        public get r(): number {
            return this.currentColor.r;
        }
        public set r(newValue: number) {
            if(newValue >= 0 && newValue <= 255) {
                this.currentColor.r = newValue;
            } else {
                throw new Error("Invalid value");
            }
        }

        public get g(): number {
            return this.currentColor.g;
        }
        public set g(newValue: number) {
            if(newValue >= 0 && newValue <= 255) {
                this.currentColor.g = newValue;
            } else {
                throw new Error("Invalid value");
            }
        }

        public get b(): number {
            return this.currentColor.b;
        }
        public set b(newValue: number) {
            if(newValue >= 0 && newValue <= 255) {
                this.currentColor.b = newValue;
            } else {
                throw new Error("Invalid value");
            }
        }

        public get a(): number {
            return this.currentColor.a;
        }
        public set a(newValue: number) {
            if(newValue >= 0 && newValue <= 1) {
                this.currentColor.a = newValue;
            } else {
                throw new Error("Invalid value for A (Alpha). It should be between 0 and 1.");
            }
        }

		public get h(): number {
			return this.hsl.h;
		}
		public set h(newValue: number) {
			if (newValue >= 0 && newValue <= 360) {
				let currentHSL = this.hsl;
				currentHSL.h = newValue;
				this.currentColor = { ...this.hslToRgb(currentHSL.h, currentHSL.s, currentHSL.l), a: this.currentColor.a };
			} else {
				throw new Error("Invalid value for H (Hue). It should be between 0 and 360.");
			}
		}

        /**
         * The hex format of the color
         */
        public get hex(): string {
            return this.rgbToHex(this.currentColor.r, this.currentColor.g, this.currentColor.b, this.currentColor.a);
        }
        public set hex(hexString: string) {
            this.currentColor = this.hexStringToRgba(hexString);
        }
        /**
         * The rgb format of the color
         */
        public get rgb(): RGBColor {
            const { r, g, b } = this.currentColor;
            return { r, g, b };
        }
        public get rgbString(): string {
            const { r, g, b } = this.rgb;
            return `rgb(${r}, ${g}, ${b})`;
        }
        public set rgb(value: RGBColor | string) {
            if(typeof value == 'string') {
                this.currentColor = { ...this.stringToRgba(value), a: this.currentColor.a };
            }
            else if(
                typeof value === 'object' &&
                !Array.isArray(value) &&
                value !== null
            ) {
                value.r = Math.min(Math.max(value.r, 0), 255);
                value.g = Math.min(Math.max(value.g, 0), 255);
                value.b = Math.min(Math.max(value.b, 0), 255);
                this.currentColor = { ...value, a: this.currentColor.a };
            }
        }
        /**
         * The rgba format of the color
         */
        public get rgba(): RGBAColor {
            return this.currentColor;
        }
        public set rgba(value: RGBAColor | string) {
            if(typeof value == 'string') {
                this.currentColor = this.stringToRgba(value);
            } else if(
                typeof value === 'object' &&
                !Array.isArray(value) &&
                value !== null
            ) {
                value.r = Math.min(Math.max(value.r, 0), 255);
                value.g = Math.min(Math.max(value.g, 0), 255);
                value.b = Math.min(Math.max(value.b, 0), 255);
                value.a = Math.min(Math.max(value.a, 0), 1);
                this.currentColor = value;
            }
        }
        public get rgbaString(): string {
            const { r, g, b, a } = this.rgba;
            return `rgba(${r}, ${g}, ${b}, ${a})`;
        }
        /**
         * The hsl format of the color
         */
        public get hsl(): HSLColor {
            const { h, s, l } = this.rgbToHsl(this.currentColor.r, this.currentColor.g, this.currentColor.b);
            return { h, s, l };
        }
        public get hslString(): string {
            const { h, s, l } = this.hsl;
            return `hsl(${h}, ${s}, ${l})`;
        }
        public set hsl(value: HSLColor | string) {
            if(typeof value == 'string') {
                this.currentColor = { ...this.hslaStringToRgba(value), a: this.currentColor.a };
            } else if(
                typeof value === 'object' &&
                !Array.isArray(value) &&
                value !== null
            ) {
                this.currentColor = { ...this.hslToRgb(value.h, value.s, value.l), a: this.currentColor.a };
            }
        }
        /**
        * The hsla format of the color
        */
        public get hsla(): HSLAColor {
            return this.rgbToHsla(this.currentColor.r, this.currentColor.g, this.currentColor.b, this.currentColor.a);
        }
        public get hslaString(): string {
            const { h, s, l, a } = this.hsla;
            return `hsla(${h}, ${s}, ${l}, ${a})`;
        }
        public set hsla(value: HSLAColor | string) {
            if(typeof value == 'string') {
                this.currentColor = this.hslaStringToRgba(value);
            } else if(
                typeof value === 'object' &&
                !Array.isArray(value) &&
                value !== null
            ) {
                this.currentColor = this.hslaToRgba(value.h, value.s, value.l, value.a);
            }
        }

        /**
         * The hsv format of the color
         */
        public get hsv(): HSVColor {
            const { h, s, v } = this.rgbToHsv(this.currentColor.r, this.currentColor.g, this.currentColor.b);
            return { h, s, v };
        }
        public get hsvString(): string {
            const { h, s, v } = this.hsv;
            return `hsv(${h}, ${s}%, ${v}%)`;
        }
        public set hsv(value: HSVColor | string) {
            if(typeof value === 'string') {
                this.currentColor = { ...this.hsvaStringToRgba(value), a: this.currentColor.a };
            } else if(
                typeof value === 'object' &&
                !Array.isArray(value) &&
                value !== null
            ) {
                this.currentColor = { ...this.hsvaToRgba(value.h, value.s, value.v, this.currentColor.a) };
            }
        }

        /**
         * The hsva format of the color
         */
        public get hsva(): HSVAColor {
            return this.rgbToHsva(this.currentColor.r, this.currentColor.g, this.currentColor.b, this.currentColor.a);
        }
        public get hsvaString(): string {
            const { h, s, v, a } = this.hsva;
            return `hsva(${h}, ${s}%, ${v}%, ${a})`;
        }
        public set hsva(value: HSVAColor | string) {
            if(typeof value === 'string') {
                this.currentColor = this.hsvaStringToRgba(value);
            } else if(
                typeof value === 'object' &&
                !Array.isArray(value) &&
                value !== null
            ) {
                this.currentColor = this.hsvaToRgba(value.h, value.s, value.v, value.a);
            }
        }

        /**
         * Create a new color
         * @param {string} colorString - The color in hex or rgb format
         */
        public constructor(colorString?: string) {
            let currentColor: RGBAColor;
            if(colorString === "" || !colorString) {
                colorString = "#ffffff";
            }
            let colorType = Color.getColorType(colorString);
            if(colorType !== -1) {
                if(colorType === Color.types.static) {
                    let staticColor = Colors[colorString.toUpperCase()] as Color | undefined;
                    if(staticColor instanceof Color) {
                        currentColor = staticColor.currentColor;
                    }
                    else {
                        throw new Error("Unknown color type");
                    }
                }
                else if(colorType === Color.types.rgb || colorType === Color.types.rgba) {
                    currentColor = this.stringToRgba(colorString);
                } else if(colorType === Color.types.hex) {
                    currentColor = this.hexStringToRgba(colorString);
                } else if(colorType === Color.types.hsl || colorType === Color.types.hsla) {
                    currentColor = this.hslaStringToRgba(colorString);
                } else {
                    throw new Error("Unknown color type");
                }
            } else {
                throw new Error(`${colorString} is not a supported color`);
            }

            this._watcher = Aventus.Watcher.get({ currentColor }, () => {
                this.onColorChange.trigger([]);
            });
        }

        public setColorTxt(colorString?: string) {
            if(colorString === "" || !colorString) {
                colorString = "#ffffff";
            }
            let colorType = Color.getColorType(colorString);
            if(colorType !== -1) {
                if(colorType === Color.types.static) {
                    let staticColor = Colors[colorString.toUpperCase()] as Color | undefined;
                    if(staticColor instanceof Color) {
                        this.currentColor = staticColor.currentColor;
                    }
                    else {
                        throw new Error("Unknown color type");
                    }
                }
                else if(colorType === Color.types.rgb || colorType === Color.types.rgba) {
                    this.currentColor = this.stringToRgba(colorString);
                } else if(colorType === Color.types.hex) {
                    this.currentColor = this.hexStringToRgba(colorString);
                } else if(colorType === Color.types.hsl || colorType === Color.types.hsla) {
                    this.currentColor = this.hslaStringToRgba(colorString);
                } else {
                    throw new Error("Unknown color type");
                }
            } else {
                throw new Error(`${colorString} is not a supported color`);
            }
        }

        public onColorChange: Aventus.Callback<() => void> = new Aventus.Callback();

        private hexStringToRgba(hexColorString: string): RGBAColor {
            // source : https://stackoverflow.com/a/5624139
            // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
            let shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i;
            hexColorString = hexColorString.replace(shorthandRegex, function (m, r, g, b, a) {
                return r + r + g + g + b + b + (a ? a + a : "");;
            });

            let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(hexColorString);
            if(!result) {
                console.error(`Invalid hex string : ${hexColorString}`);
                return {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 1
                };
            } else {
                return {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16),
                    a: result[4] ? parseInt(result[4], 16) / 255 : 1
                };
            }
        }
        private stringToRgba(rgbColorString: string): RGBAColor {
            let splitted: string[] = rgbColorString.replaceAll(/[\(\)rgb ]/g, "").split(",");
            let result: number[] = [];
            for(let i = 0; i < 4; i++) {
                if(i < 3) {
                    result.push(Math.min(Math.max(parseInt(splitted[i]), 0), 255));
                } else {
                    result.push(Math.min(Math.max(parseFloat(splitted[i]), 0), 1));
                }
            }
            return {
                r: result[0],
                g: result[1],
                b: result[2],
                a: result[3] || 1
            };
        }

        private rgbToHex(r: number, g: number, b: number, a: number = 1) {
            let hex = "#" + ((1 << 24) + (Math.round(r) << 16) + (Math.round(g) << 8) + Math.round(b)).toString(16).slice(1);
            if(a < 1) {
                let alphaHex = Math.round(a * 255).toString(16).padStart(2, '0');
                hex += alphaHex;
            }
            return hex;
        }

        private hslStringToRgb(hslColorString: string): RGBColor {
            let [h, s, l] = hslColorString.replaceAll(/[\(\)hsl% ]/g, "").split(",").map(Number);
            return this.hslToRgb(h, s, l);
        }
        private rgbToHsl(r: number, g: number, b: number): HSLColor {
            r /= 255;
            g /= 255;
            b /= 255;
            let max = Math.max(r, g, b);
            let min = Math.min(r, g, b);
            let h: number, s: number, l: number = (max + min) / 2;

            if(max == min) {
                h = s = 0; // achromatic
            } else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch(max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                    default: h = 0;
                }
                h /= 6;
            }

            return {
                h: this.round(h * 360),
                s: this.round(s * 100),
                l: this.round(l * 100)
            };
        }
        private rgbToHsla(r: number, g: number, b: number, a: number): HSLAColor {
            let hsl = this.rgbToHsl(r, g, b);
            return { ...hsl, a: a };
        }
        private hslToRgb(h: number, s: number, l: number): RGBColor {
            s /= 100;
            l /= 100;

            let c = (1 - Math.abs(2 * l - 1)) * s;
            let x = c * (1 - Math.abs((h / 60) % 2 - 1));
            let m = l - c / 2;
            let r = 0, g = 0, b = 0;

            if(0 <= h && h < 60) {
                r = c; g = x; b = 0;
            } else if(60 <= h && h < 120) {
                r = x; g = c; b = 0;
            } else if(120 <= h && h < 180) {
                r = 0; g = c; b = x;
            } else if(180 <= h && h < 240) {
                r = 0; g = x; b = c;
            } else if(240 <= h && h < 300) {
                r = x; g = 0; b = c;
            } else if(300 <= h && h <= 360) {
                r = c; g = 0; b = x;
            }

            return {
                r: this.round((r + m) * 255),
                g: this.round((g + m) * 255),
                b: this.round((b + m) * 255)
            };
        }
        private hslaToRgba(h: number, s: number, l: number, a: number): RGBAColor {
            let rgb = this.hslToRgb(h, s, l);
            return { ...rgb, a: a };
        }
        private hslaStringToRgba(hslaColorString: string): RGBAColor {
            let [h, s, l, a] = hslaColorString.replaceAll(/[\(\)hsla% ]/g, "").split(",").map(Number);
            return this.hslaToRgba(h, s, l, a);
        }

        private rgbToHsv(r: number, g: number, b: number): HSVColor {
            r /= 255;
            g /= 255;
            b /= 255;
            let max = Math.max(r, g, b);
            let min = Math.min(r, g, b);
            let h: number, s: number, v: number = max;

            let delta = max - min;
            s = max === 0 ? 0 : delta / max;

            if(delta === 0) {
                h = 0;
            } else {
                switch(max) {
                    case r:
                        h = (g - b) / delta + (g < b ? 6 : 0);
                        break;
                    case g:
                        h = (b - r) / delta + 2;
                        break;
                    case b:
                        h = (r - g) / delta + 4;
                        break;
                    default:
                        h = 0;
                }
                h /= 6;
            }

            return {
                h: this.round(h * 360),
                s: this.round(s * 100),
                v: this.round(v * 100)
            };
        }
        private hsvToRgb(h: number, s: number, v: number): RGBColor {
            s /= 100;
            v /= 100;
            let c = v * s;
            let x = c * (1 - Math.abs((h / 60) % 2 - 1));
            let m = v - c;
            let r = 0, g = 0, b = 0;

            if(0 <= h && h < 60) {
                r = c; g = x; b = 0;
            } else if(60 <= h && h < 120) {
                r = x; g = c; b = 0;
            } else if(120 <= h && h < 180) {
                r = 0; g = c; b = x;
            } else if(180 <= h && h < 240) {
                r = 0; g = x; b = c;
            } else if(240 <= h && h < 300) {
                r = x; g = 0; b = c;
            } else if(300 <= h && h <= 360) {
                r = c; g = 0; b = x;
            }

            return {
                r: this.round((r + m) * 255),
                g: this.round((g + m) * 255),
                b: this.round((b + m) * 255)
            };
        }

        private rgbToHsva(r: number, g: number, b: number, a: number): HSVAColor {
            let hsv = this.rgbToHsv(r, g, b);
            return { ...hsv, a };
        }
        private hsvaToRgba(h: number, s: number, v: number, a: number): RGBAColor {
            let rgb = this.hsvToRgb(h, s, v);
            return { ...rgb, a };
        }
        private hsvaStringToRgba(hsvaColorString: string): RGBAColor {
            let [h, s, v, a] = hsvaColorString.replaceAll(/[\(\)hsva% ]/g, "").split(",").map(Number);
            return this.hsvaToRgba(h, s, v, a);
        }

        private round(nb: number) {
            return Math.round(nb * 100) / 100;
        }
        /**
         * Print the color in hex format
         * @returns {string} - A pretty print of the color in hex format
         */
        public toString(): string {
            return this.rgbToHex(this.currentColor.r, this.currentColor.g, this.currentColor.b, this.currentColor.a);
        }
    }
}