import type { VirtualForm } from "../components/ui/form/Form/VirtualForm.lib.avt";
import { formDataBuilder, type BodyJSON, type FormData, type formDataBuilderSettings } from "../components/ui/form/Form/FormType.lib.avt";
import { Form } from "../components/ui/form/Form/Form.wcl.avt";
import { ApplicationStorableState } from "./ApplicationState.state.avt";

namespace State {
    export abstract class CreateOrUpdate<T extends AventusSharp.Data.Storable, U extends BodyJSON> extends ApplicationStorableState<T> implements Aventus.IState {

        private static _state: string = "";
        public static get state(): string {
            if(this._state == "") {
                let cst = this as any;
                // if the state is not defined we must create it
                new cst();
            }
            return this._state;
        }

        protected __form: VirtualForm<U>;
        public get form(): VirtualForm<U> {
            return this.__form;
        }

        public constructor(item?: T) {
            super(item);

            this.constructor['_state'] = this.genericState();
            this.__form = Aventus.Watcher.get(Form.create(this.defineFormSchema()));
        }

        protected override refreshItem(key: string): void {
            super.refreshItem(key);
            this.form?.refresh(key as Extract<keyof U, string>);
        }

        /**
         * @inheritdoc
         */
        public override get name(): string {
            return this.genericState().replace("{id:number}", this.item.Id + "");
        }

        private genericState() {
            return `/${this.defineObjectName().toLowerCase()}/{id:number}`;
        }

        protected abstract defineRAM(): Aventus.Ram<T>;

        protected abstract defineObjectName(): string;

        protected abstract defineFormSchema(): FormData<U>;

        protected autoForm(element: U, settings?: formDataBuilderSettings<U>): FormData<U> {
            return formDataBuilder(element, settings);
        }

        /**
         * This will validate the form and save the model though the ram
         * Errors are deals by this method. If success, result !== undefined
         */
        public async save(): Promise<T | undefined> {
            let result: T | undefined;
            const validationResult = await this.form.validate(this.application);
            if(validationResult === true) {
                let ramResult: Aventus.ResultRamWithError<Aventus.RamItem<T>> | null;
                if(this.item.Id == 0) {
                    ramResult = await this.application.showLoading(this.defineRAM().createWithError(this.item));
                }
                else {
                    ramResult = await this.application.showLoading(this.defineRAM().updateWithError(this.item));
                }

                if(ramResult == null) {
                    return undefined;
                }

                if(ramResult.errors.length > 0) {
                    let noPrintErrors: Aventus.GenericError[] = [];
                    for(let error of ramResult.errors) {
                        if(error.details) {
                            let found = false;
                            for(let detail of error.details) {
                                if(detail instanceof AventusSharp.Data.FieldErrorInfo) {
                                    if(this.form.addFieldError(detail.Name, error.message)) {
                                        found = true;
                                        break;
                                    }
                                }
                            }
                            if(found) {
                                continue;
                            }
                        }

                        noPrintErrors.push(error);
                    }
                    ramResult.errors = noPrintErrors;
                }
                return await this.application.parseErrors(ramResult);
            }

            return result;
        }
        public back() {
            const splitted = this.name.split("/");
            splitted.pop();
            this.application.navigate(splitted.join("/"));
        }
        public cancel() {
            this.back();
        }
    }
}