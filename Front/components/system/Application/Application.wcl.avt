import { FrameNoScroll } from "../Frame/FrameNoScroll/FrameNoScroll.wcl.avt";
import { ApplicationHistory } from "./ApplicationHistory.lib.avt";
import { Resize, ResizeDirection } from "../../ui/Resize/Resize.wcl.avt";
import { ApplicationStateManager } from "../../../libs/ApplicationStateManager.state.avt";
import { Popup, type PopupInfo } from "../../ui/popup/Popup/Popup.wcl.avt";
import { Alert, type AlertInfo } from "../../ui/popup/Alert/Alert.wcl.avt";
import { Confirm, type ConfirmInfo } from "../../ui/popup/Confirm/Confirm.wcl.avt";
import { ApplicationOpen, ApplicationOpenInfo } from "../../../generated/Data/ApplicationOpen.lib.avt";
import { ApplicationManager } from "../../../libs/ApplicationManager.lib.avt";
import { Frame404 } from "../Frame/Frame404/Frame404.wcl.avt";
import { ApplicationSize, type ApplicationPositionSize } from "./ApplicationSize.lib.avt";
import type { Desktop } from "../Desktop/Desktop.wcl.avt";
import type { ContextMenu, IContextMenu } from "../../ui/ContextMenu/ContextMenu.wcl.avt";
import { Geometry, type Rectangle } from "../../../libs/Geometry.lib.avt";
import type { ApplicationQueryFct, ApplicationQueryFctResult, ApplicationQueryResult, GetArgs } from "./ApplicationError.lib.avt";
import { ShortcutManager, SpecialTouch } from "../../../libs/ShortcutManager.lib.avt";
import { Os } from "../Os/Os.wcl.avt";
import { DesktopActivableLogic, type IDesktopActivable } from "../Desktop/IActivable.lib.avt";
import { ApplicationState } from "../../../states/ApplicationState.state.avt";
import type { GenericPopup } from "../../ui/popup/GenericPopup/GenericPopup.wcl.avt";
import { FrameNotAllowed } from "../Frame/FrameNotAllowed/FrameNotAllowed.wcl.avt";
import type { ContextMenuElement } from "../../ui/ContextMenu/ContextMenuElement/ContextMenuElement.wcl.avt";

namespace System {

    export type ApplicationRoute = {
        route: string,
        scriptUrl: string,
        render: () => new () => FrameNoScroll;
    };

    export type ApplicationInitOptions = {
        applicationNumber: number,
        desktopId: number;
        desktop: Desktop;
    };

    export type ExtractTypePopup<X extends GenericPopup<U, Y>, U = any, Y extends PopupInfo = any> = X extends GenericPopup<infer U, Y> ? U : never;

    /**
     * Represent a window inside the OS
     */
    export abstract class Application extends Aventus.WebComponent implements Aventus.DefaultComponent, IDesktopActivable {

        //#region static

        //#endregion


        //#region props
        @Property()
        public app_title: string = "Page title";
        @Attribute()
        public moving: boolean = false;
        /**
         * Determine if the app is in fullscreen when screen is >= tablette
         */
        @Property((target: Application) => {
            target.saveSize();
        })
        public full: boolean = false;
        @Property((target: Application) => {
            target.onIsHiddenChange();
        })
        public is_hidden: boolean = false;

        @Attribute()
        public loading: boolean = false;

        //#endregion


        //#region variables
        @ViewElement()
        protected header!: ContextMenuElement;
        @ViewElement()
        protected resizeEl!: Resize;
        @ViewElement()
        protected contentEl!: ContextMenuElement;
        @ViewElement()
        protected navigatePreviousEl!: HTMLDivElement;
        @ViewElement()
        protected navigateNextEl!: HTMLDivElement;

        @Watch((target: Application) => {
            target.manageShortcut();
        })
        public is_desktop_active: boolean = false;


        private oldFrame: FrameNoScroll | undefined;
        protected allRoutes: { [key: string]: ApplicationRoute; } = {};
        private activePath: string = "";
        protected activeState?: Aventus.State;
        private showPageMutex: Aventus.Mutex = new Aventus.Mutex();
        private router?: ApplicationStateManager;
        @Internal()
        public options?: ApplicationInitOptions;
        private history: ApplicationHistory;
        @Internal()
        public mustRemoveApplicationHistory: boolean = true;
        private oneStateActive: boolean = false;
        protected page404?: FrameNoScroll;
        protected page405?: FrameNoScroll;

        protected sizeManager: ApplicationSize;
        protected isAnimating: boolean = false;
        private afterTransitionCb: (() => void)[] = [];
        //#endregion


        //#region constructor
        constructor() {
            super();
            this.history = new ApplicationHistory();
            this.sizeManager = new ApplicationSize(this);
            this.canChangeState = this.canChangeState.bind(this);
            this.navigator.canChangeState(this.canChangeState);
        }
        //#endregion


        //#region methods

        //#region context menu
        /**
         * Use this function to add anything you want to display when user trigger the context menu on the content
         */
        @BindThis()
        public onContextMenuContent(contextMenu: ContextMenu, stop: () => void): void {
            stop();
        }

        /**
         * Use this function to add anything you want to display when user trigger the context menu on the header
         */
        @BindThis()
        public onContextMenuHeader(contextMenu: ContextMenu, stop: () => void): void {
            contextMenu.addItem({
                text: "Recentrer la fenetre",
                icon: "/img/icons/window-restore.svg",
                priority: 2,
                action: () => {
                    this.resetSize();
                }
            });
            stop();
        }

        protected bindContextMenu() {
            this.header.onContextMenu = this.onContextMenuHeader;
            this.contentEl.onContextMenu = this.onContextMenuContent;
        }
        //#endregion


        //#region routing
        /**
         * Add all your routes inside this function (addRoute or addRouteAsync)
         */
        protected abstract defineRoutes(): Promise<void>;
        /**
         * Gets the navigator instance for managing application states.
         */
        public get navigator(): ApplicationStateManager {
            if(!this.router) {
                this.router = new ApplicationStateManager(this);
            }
            return this.router;
        }

        /**
         * Allow you to navigate between frames
         */
        public async navigate(to: string | Aventus.State) {
            let hasChanged = await this.navigator.setState(to);
            let state = this.navigator.getState();
            if(state && hasChanged) {
                this.history.push({
                    state: state
                });
                this.checkNavigationState();
                this.saveApplicationHistory();
            }
            return hasChanged;
        }
        /**
         * Adds a route asynchronously.
         */
        protected addRouteAsync<T extends FrameNoScroll>(options: ApplicationRoute) {
            this.allRoutes[options.route] = options;
        }
        /**
         * Adds a route.
         */
        protected addRoute(route: string, frame: new () => FrameNoScroll) {
            this.allRoutes[route] = {
                route: route,
                scriptUrl: '',
                render: () => frame
            };
        }
        /**
         * Registers the application routes and initializes them.
         */
        private register(): void {
            try {
                this.defineRoutes();
                this.navigator.onAfterStateChanged(this.validError404);
                for(let key in this.allRoutes) {
                    this.initRoute(key);
                }
            } catch(e) {
                console.log(e);
            }
        }

        /**
         *  Defines the keyboard shortcuts for the application.
         */
        protected defineShortcut(): [(string | SpecialTouch)[], cb: () => void][] {
            return [
                [[SpecialTouch.Control, SpecialTouch.ArrowLeft], this.moveApplicationToLeft],
                [[SpecialTouch.Control, SpecialTouch.ArrowRight], this.moveApplicationToRight]
            ];
        }
        /**
         *  Manages the keyboard shortcuts for the application
         */
        private manageShortcut() {
            let shortcuts = this.defineShortcut();
            if(this.is_desktop_active) {
                for(let shortcut of shortcuts) {
                    ShortcutManager.subscribe(shortcut[0], shortcut[1]);
                }
            }
            else {
                for(let shortcut of shortcuts) {
                    ShortcutManager.unsubscribe(shortcut[0], shortcut[1]);
                }
            }
        }


        /**
         * Determine if the frame should be destroyed when hiding
         */
        protected shouldDestroyFrame(frame: FrameNoScroll): boolean {
            return false;
        }
        /**
         * Initializes the route for a given path.
         */
        private initRoute(path: string) {
            let element: FrameNoScroll | undefined;
            let allRoutes = this.allRoutes;
            this.navigator.subscribe(path, {
                active: (currentState) => {
                    this.oneStateActive = true;
                    this.showPageMutex.safeRunLastAsync(async () => {
                        try {
                            if(!element) {
                                let options = allRoutes[path];
                                if(options.scriptUrl != "") {
                                    await Aventus.ResourceLoader.loadInHead(options.scriptUrl);
                                }

                                let cst = options.render();
                                element = new cst;
                                element.application = this;
                                element.resetNavElement = () => element = undefined;
                                this.contentEl?.appendChild(element);
                            }

                            let isAllowed = await element.testPermissions();
                            if(!isAllowed) {
                                this.showErrorNotAllowed();
                                return;
                            }
                            const canResult = await element.can(currentState);
                            if(canResult !== true) {
                                if(canResult === false) {
                                    this.showErrorNotAllowed();
                                }
                                else {
                                    this.navigate(canResult);
                                }
                                return;
                            }
                            if(this.oldFrame && this.oldFrame != element) {
                                await this.oldFrame.hide();
                                if(this.shouldDestroyFrame(this.oldFrame)) {
                                    this.oldFrame.remove();
                                    this.oldFrame.resetNavElement();
                                }
                            }

                            let oldPage = this.oldFrame;
                            let oldUrl = this.activePath;
                            this.oldFrame = element;
                            this.activePath = path;
                            this.activeState = currentState;
                            await element.show(currentState);

                            let titleTemp = element.pageTitle();
                            if(titleTemp !== undefined) {
                                this.app_title = titleTemp;
                            }

                            this.onNewPage(oldUrl, oldPage, path, element);
                        } catch(e) {
                            console.error(e);
                        }
                    });
                },
                inactive: () => {
                    this.oneStateActive = false;
                }
            });
        }

        /**
         * Validates and handles 404 errors.
         */
        @BindThis()
        protected async validError404() {
            if(!this.oneStateActive) {
                let frameError = this.error404(this.navigator.getState());
                if(!this.page404) {
                    this.page404 = new frameError();
                    this.page404.application = this;
                    this.contentEl.appendChild(this.page404);
                }
                if(this.oldFrame && this.oldFrame != this.page404) {
                    await this.oldFrame.hide();
                }
                await this.page404.show(undefined);
                this.oldFrame = this.page404;
                this.activePath = '';
            }
        }
        /**
         * Returns the frame class for 404 errors.
         */
        protected error404(state?: Aventus.State): (new () => FrameNoScroll) {
            return Frame404;
        }

        /**
         * Shows an error when access is not allowed.
         */
        @BindThis()
        protected async showErrorNotAllowed() {
            let frameError = this.errorNotAllowed(this.navigator.getState());
            if(!this.page405) {
                this.page405 = new frameError();
                this.page405.application = this;
                this.contentEl.appendChild(this.page405);
            }
            if(this.oldFrame && this.oldFrame != this.page405) {
                await this.oldFrame.hide();
            }
            await this.page405.show(undefined);
            this.oldFrame = this.page405;
            this.activePath = '';
        }
        /**
         * Returns the frame class for "not allowed" errors.
         */
        protected errorNotAllowed(state?: Aventus.State): (new () => FrameNoScroll) {
            return FrameNotAllowed;
        }

        /**
         * Handles the transition to a new page.
         */
        protected onNewPage(oldUrl: string, oldFrame: FrameNoScroll | undefined, newUrl: string, newFrame: FrameNoScroll) { }
        /**
         * Gets the slugs of the current state.
         */
        public getSlugs() {
            return this.navigator.getStateSlugs(this.activePath);
        }

        /**
         * Determines if the application can change to a new state.
         */
        protected async canChangeState(newState: Aventus.State): Promise<boolean> {
            if(!this.oldFrame) return true;

            return await this.oldFrame.askChange(newState);
        }

        /**
         * Checks and updates the navigation state (previous/next availability).
         */
        protected checkNavigationState() {
            if(this.history.previousAvailable) {
                this.navigatePreviousEl.classList.remove("disable");
            }
            else {
                this.navigatePreviousEl.classList.add("disable");
            }
            if(this.history.nextAvailable) {
                this.navigateNextEl.classList.remove("disable");
            }
            else {
                this.navigateNextEl.classList.add("disable");
            }
        }
        /**
         * Navigates to the previous state in the history.
         */
        public async navigatePrevious(destroy: boolean = false) {
            let history = this.history.previous(destroy);
            if(history) {
                if(await this.navigator.setState(history.state)) {
                    this.checkNavigationState();
                    this.saveApplicationHistory();
                }
                else {
                    this.history.cancelPrevious();
                }
            }
        }

        /**
         * Navigates to the next state in the history.
         */
        public async navigateNext() {
            let history = this.history.next();
            if(history) {
                if(await this.navigator.setState(history.state)) {
                    this.checkNavigationState();
                    this.saveApplicationHistory();
                }
                else {
                    this.history.cancelNext();
                }
            }
        }

        /**
         * Subscribes to navigation state changes.
         */
        public subscribeNavigationChange(statePatterns: string | string[], callbacks: Aventus.StateAction): void {
            this.navigator.subscribe(statePatterns, callbacks);
        }
        /**
         * Unsubscribes from navigation state changes.
         */
        public unsubscribeNavigationChange(statePatterns: string | string[], callbacks: Aventus.StateAction): void {
            this.navigator.unsubscribe(statePatterns, callbacks);
        }

        /**
         * Sets the application history.
         */
        public async setHistory(history: ApplicationHistory) {
            this.history = history;
            let current = this.history.current();
            if(current) {
                if(this.navigator.isStateActive(current.state.name)) {
                    let state = this.navigator.getState();
                    if(state?.constructor == current.state.constructor && state instanceof ApplicationState && current.state instanceof ApplicationState) {
                        state.disableSaveState();
                        state.copyValues(current.state);
                        this.history.replace({ state });
                        state.enableSaveState();
                    }
                    else {
                        await this.navigator.setState("");
                        await this.navigator.setState(current.state);
                    }
                }
                else {
                    await this.navigator.setState(current.state);
                }
                this.checkNavigationState();
            }
        }

        /**
         * Saves the application history.
         */
        @BindThis()
        public async saveApplicationHistory() {
            if(!this.options) {
                return;
            }

            let app = new ApplicationOpen();
            app.applicationName = this.$type;
            app.number = Number(this.options.applicationNumber);
            app.history = this.history.toText();
            app.isHidden = this.is_hidden;

            let appInfo = new ApplicationOpenInfo();
            appInfo.DesktopId = this.options.desktopId;
            appInfo.Info = app;
            await ApplicationManager.save(appInfo);
        }

        /**
         * Removes the application history
         */
        protected async removeApplicationHistory() {
            if(!this.options) {
                return;
            }
            if(!this.mustRemoveApplicationHistory) {
                return;
            }

            let app = new ApplicationOpen();
            app.applicationName = this.$type;
            app.number = Number(this.options.applicationNumber);
            app.isHidden = this.is_hidden;
            app.history = '{}';

            let appInfo = new ApplicationOpenInfo();
            appInfo.DesktopId = this.options.desktopId;
            appInfo.Info = app;

            await ApplicationManager.remove(appInfo);
        }


        //#endregion

        //#region position + size
        /**
         * Handles the start of a resize operation.
         */
        @BindThis()
        private onResizeStart(direction: ResizeDirection) {
            this.moving = true;
        }
        /**
         * Handles the end of a resize operation.
         */
        @BindThis()
        private onResizeStop(direction: ResizeDirection) {
            this.moving = false;
            this.saveSize();
        }

        /**
         * Trigger when the property is_hidden changed
         */
        protected onIsHiddenChange() {
            if(!this.checkIfSizeCorrect()) {
                this.resetSize();
            }
        }

        /**
         * Save the size for the current application inside local storage
         * It will wait the end of the transition
         */
        public saveSize() {
            this.afterTransition(() => {
                this.sizeManager.save();
            });
        }
        /**
         * Reset the size to the basic information
         */
        public resetSize() {
            this.setSizeInfo(ApplicationSize.getBasicSize());
            this.saveSize();
        }
        /**
         * Check if the application size is wide enough
         */
        private checkIfSizeCorrect(): boolean {
            if(this.is_hidden) {
                return true;
            }
            let stylePart: { [prop: string]: string; } = {};
            let style = this.getAttribute("style")?.split(";");
            if(style) {
                for(let part of style) {
                    part = part.trim();
                    if(part != "") {
                        let splitted = part.split(":");
                        stylePart[splitted[0]] = splitted[1].trim();
                    }
                }
            }

            let left = Number(stylePart.left?.replace("px", ""));
            let width = Number(stylePart.width?.replace("px", ""));
            let top = Number(stylePart.top?.replace("px", ""));
            let height = Number(stylePart.height?.replace("px", ""));
            let frameRect: Rectangle = {
                x1: left,
                x2: left + width,
                y1: top,
                y2: top + height
            };

            let bodyRect: Rectangle = {
                x1: 0,
                x2: document.body.offsetWidth,
                y1: 0,
                y2: document.body.offsetHeight
            };
            let intersection = Geometry.getIntersectingRectangle(frameRect, bodyRect);
            if(intersection) {
                if(Math.abs(intersection.x2 - intersection.x1) < 100) {
                    return false;
                }
                if(Math.abs(intersection.y2 - intersection.y1) < 100) {
                    return false;
                }
                let areaIntersection = Geometry.getRectangleArea(intersection);
                if(areaIntersection < 10000) {
                    return false;
                }
                return true;
            }
            return false;
        }
        /**
         * Define the size wanted for the current 
         */
        private setSizeInfo(info: ApplicationPositionSize) {
            this.moveApplication(info);
            this.full = info.isFullScreen;
        }

        /**
         * Moves the application to the specified position and size.
         */
        public moveApplication(options: { left?: number, top?: number, width?: number, height?: number; }) {
            if(options.left != undefined)
                this.style.left = options.left + 'px';
            if(options.top != undefined)
                this.style.top = options.top + 'px';
            if(options.width != undefined)
                this.style.setProperty("--app-width", options.width + "px");
            if(options.height != undefined)
                this.style.setProperty("--app-height", options.height + "px");
        }

        /**
         * ;oves the application to the left side of the screen.
         */
        @BindThis()
        protected moveApplicationToLeft() {
            this.moveApplication({
                top: 5,
                left: 5,
                height: Os.instance.offsetHeight - 10,
                width: Os.instance.offsetWidth / 2 - 7,
            });
            this.saveSize();
        }
        /**
         * Moves the application to the right side of the screen.
         */
        @BindThis()
        protected moveApplicationToRight() {
            this.moveApplication({
                top: 5,
                left: Os.instance.offsetWidth / 2 + 2,
                height: Os.instance.offsetHeight - 10,
                width: Os.instance.offsetWidth / 2 - 7,
            });
            this.saveSize();
        }

        /**
         * Add the drag and drop action to move the application with the navbar
         */
        protected addMoveDragAndDrop() {
            let hasMove = false;
            new Aventus.DragAndDrop({
                element: this,
                elementTrigger: this.header,
                offsetDrag: 5,
                isDragEnable: () => {
                    return !this.full;
                },
                onPointerDown: () => {
                    hasMove = false;
                },
                onStart: (e) => {
                    this.moving = true;
                },
                onMove: () => {
                    hasMove = true;
                },
                onPointerUp: () => {
                    this.moving = false;
                    if(hasMove)
                        this.saveSize();
                }
            });

            this.header.addEventListener("dblclick", () => {
                this.toggleFull();
            });
        }

        /**
         * Add the bind to the resize function
         */
        protected addResize() {
            this.resizeEl.init(this, {
                applyWidth: (value) => this.style.setProperty("--app-width", value + "px"),
                applyHeight: (value) => this.style.setProperty("--app-height", value + "px")
            });
            this.resizeEl.onPointerDown.add(this.onResizeStart);
            this.resizeEl.onPointerUp.add(this.onResizeStop);
        }

        /**
         * Executes a callback after a transition ends
         */
        public afterTransition(cb: () => void) {
            setTimeout(() => {
                if(this.isAnimating) {
                    this.afterTransitionCb.push(cb);
                    return;
                }
                cb();
            }, 100);
        }
        /**
         * Watches for transition events and handles them
         */
        protected watchTransition() {
            this.addEventListener("transitionstart", () => {
                this.isAnimating = true;
            });
            this.addEventListener("transitionend", () => {
                this.isAnimating = false;
                let cbs = [...this.afterTransitionCb];
                for(let cb of cbs) {
                    cb();
                }
                this.afterTransitionCb = [];
            });
        }
        //#endregion

        //#region navbar
        /**
         * Toggles the fullscreen mode of the application.
         */
        public toggleFull() {
            this.full = !this.full;
        }
        /**
         * Hides the application.
         */
        public hide() {
            this.is_hidden = true;
            this.saveApplicationHistory();
        }
        /**
         * Shows the application.
         */
        public show() {
            this.is_hidden = false;
            this.saveApplicationHistory();
        }
        /**
         * Kills the application (removes it from the DOM).
         */
        public kill() {
            this.remove();
        }
        //#endregion

        //#region popup
        /**
         * Opens a popup and returns a promise that resolves with the popup's result.
         */
        public popup<T extends GenericPopup<U, X>, U = ExtractTypePopup<T>, X extends PopupInfo = PopupInfo>(p: T): Promise<U> {
            return new Promise<U>((resolve) => {
                p.init((response) => {
                    resolve(response);
                });
                this.shadowRoot.appendChild(p);
            });
        }
        /**
         * Shows an alert popup with the provided information.
         */
        public async alert(info: Partial<AlertInfo>): Promise<void> {
            const a = new Alert();
            a.mergeInfo(info);
            await this.popup(a);
        }
        /**
         * Shows a confirm popup with the provided information.
         */
        public async confirm(info: Partial<ConfirmInfo>): Promise<boolean> {
            const c = new Confirm();
            c.mergeInfo(info);
            return await this.popup(c);
        }
        //#endregion

        //#region execution process
        /**
         *  Parses errors from the application query result.
         */
        public async parseErrors<X>(result: ApplicationQueryFctResult<X>): Promise<X | undefined> {
            if(result.errors.length > 0) {
                let msg = result.errors.map(p => p.message).join("<br/>");
                await this.alert({
                    title: "Error",
                    description: msg,
                    behind: false,
                    min_width: '300px',
                });
                return undefined;
            }
            if(result instanceof Aventus.ResultWithError) return result.result;
            return undefined;
        }
        /**
         * Executes a promise and parses its result.
         */
        public async execute<X>(prom: Promise<ApplicationQueryFctResult<X>>): Promise<X | undefined> {
            const queryResult = await prom;
            return await this.parseErrors(queryResult);
        }
        /**
         * Executes a promise with a loading indicator and parses its result.
         */
        public async executeWithLoading<X>(prom: Promise<ApplicationQueryFctResult<X>>): Promise<X | undefined> {
            const queryResult = await this.showLoading(prom);
            return await this.parseErrors(queryResult);
        }
        /**
         * Shows a loading indicator while executing a function or promise.
         */
        public async showLoading<X>(fct: (() => Promise<X>) | Promise<X>): Promise<X> {
            const minDelay = 2000;
            let start: Date | undefined;
            let timeout = setTimeout(() => {
                start = new Date();
                this.loading = true;
            }, 200);
            let result: X;
            if(fct instanceof Promise) {
                result = await fct;
            }
            else {
                result = await fct();
            }
            clearTimeout(timeout);
            if(start) {
                let now = new Date();
                let diffMs = now.getTime() - start.getTime();
                if(diffMs < minDelay) {
                    await Aventus.sleep(minDelay - diffMs);
                }
            }
            this.loading = false;
            return result;
        }
        //#endregion

        //#region desktop activable
        /**
         * Adds focus to the application.
         */
        private addFocus() {
            this.setAttribute("tabindex", "-1");
            this.addEventListener("focus", (e) => {
                e.stopPropagation();
                this.setDesktopActive();
            });
        }
        /**
         * Sets the application as the active desktop application.
         */
        public setDesktopActive() {
            DesktopActivableLogic.set(this);
        }
        /**
         * Removes the application from the active desktop application.
         */
        public removeDesktopActive() {
            DesktopActivableLogic.remove(this);
        }
        //#endregion


        /**
         *  Initializes the application with the given options.
         */
        public init(options: ApplicationInitOptions) {
            this.options = options;
            this.setSizeInfo(this.sizeManager.load());
        }

        /**
         * @inheritdoc
         */
        protected override postCreation(): void {
            this.register();
            this.addResize();
            this.addFocus();
            this.addMoveDragAndDrop();
            this.watchTransition();
            this.bindContextMenu();
        }

        /**
         * @inheritdoc
         */
        protected override postDestruction(): void {
            super.postDestruction();
            this.options?.desktop.removeApp(this);
            this.removeDesktopActive();
            this.removeApplicationHistory();
            this.sizeManager.remove();
        }
        //#endregion

    }
}                 