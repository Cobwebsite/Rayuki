import { OptionData } from "./OptionData/OptionData.wcl.avt";
import { GenericSelect } from "../GenericSelect/GenericSelect.wcl.avt";
import { Process } from "../../../../../libs/Process.lib.avt";

namespace Components {
    export abstract class SelectData<U extends Aventus.IData, T extends U | number = U> extends GenericSelect<OptionData<T>, T> implements Aventus.DefaultComponent {

        //#region static

        //#endregion


        //#region props
        @Attribute()
        public loading!: boolean;
        @Attribute()
        public txt_undefined?: string;
        //#endregion


        //#region variables
        protected data: Aventus.RamItem<U>[] = [];
        protected isInit: boolean = false;
        //#endregion


        //#region constructor
        public constructor() {
            super();
        }
        //#endregion


        //#region methods
        /**
         * @inheritdoc
         */
        protected override itemToText(option: OptionData<T>): string {
            return option.innerHTML;
        }


        protected async createOptions() {
            this.loading = true;
            this.data = await this.loadData();
            if(this.txt_undefined !== undefined) {
                let option = new OptionData();
                option.value = undefined;
                option.innerHTML = this.txt_undefined === "" ? "&nbsp;" : this.txt_undefined;
                this.appendChild(option);
            }
            for(let item of this.data) {
                let option = new OptionData();
                option.value = await this.optionValue(item);
                option.innerHTML = await this.optionText(item);
                this.appendChild(option);
            }
            this.loading = false;
            this.init();
        }


        protected abstract defineRam(): Aventus.Ram<U>;
        protected async loadData(): Promise<Aventus.RamItem<U>[]> {
            const result = await Process.execute(this, this.defineRam().getListWithError()) ?? [];
            return result;
        }
        protected abstract optionText(item: U): Aventus.Asyncable<string>;
        protected abstract optionValue(item: U): Aventus.Asyncable<T>;

        @BindThis()
        protected subscribe() {
            this.defineRam().onCreated(this.onCreated);
            this.defineRam().onUpdated(this.onUpdated);
            this.defineRam().onDeleted(this.onDeleted);
        }

        @BindThis()
        protected unsubscribe() {
            this.defineRam().offCreated(this.onCreated);
            this.defineRam().offUpdated(this.onUpdated);
            this.defineRam().offDeleted(this.onDeleted);
        }

        @BindThis()
        protected async onCreated(item: Aventus.RamItem<U>) {
            this.data.push(item);
            let option = new OptionData();
            option.value = await this.optionValue(item);
            option.innerHTML = await this.optionText(item);
            this.appendChild(option);
            this.loadElementsFromSlot();
        }

        @BindThis()
        protected onDeleted(item: Aventus.RamItem<U>) {
            for(let i = 0; i < this.options.length; i++) {
                let option = this.options[i];
                if(option.value == this.optionValue(item)) {
                    this.options.splice(i, 1);
                    option.remove();
                    if(this.value == this.optionValue(item)) {
                        this.value = undefined;
                    }
                }
            }
        }

        @BindThis()
        protected async onUpdated(item: Aventus.RamItem<U>) {
            for(let i = 0; i < this.options.length; i++) {
                let option = this.options[i];
                if(option.value == this.optionValue(item)) {
                    option.innerHTML = await this.optionText(item);
                }
            }
        }

        protected async init() {
            if(!this.isConnected) return;
            if(this.isInit) return;
            this.isInit = true;
            await this.createOptions();
            super.postCreation();
            this.subscribe();
        }

        protected override postDestruction(): void {
            super.postDestruction();
            this.unsubscribe();
        }
        protected override postConnect(): void {
        }


        protected override postCreation(): void {
            this.init();
        }
        //#endregion

    }
}