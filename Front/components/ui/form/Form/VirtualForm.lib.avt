import type { ApplicationQueryFctResult } from "../../../system/Application/ApplicationError.lib.avt";
import { Application } from "../../../system/Application/Application.wcl.avt";
import type { BodyJSON, FormData, FormPart, FormValidateResult } from "./FormType.lib.avt";
import { FormElement } from "../FormElement/FormElement.wcl.avt";

namespace Components {

    interface InternalVirtualFormType<T extends BodyJSON> {
        /**
        * Return an array of string for all message not displayed otherwhise return a bool
        * If from is provided, an alert will be trigger if the error can't find a element
        */
        validate(from: Application): Promise<boolean>;
        validate(from?: Aventus.WebComponent): Promise<boolean | string[]>;
        addFieldError(name: keyof T, error: string): boolean;
        execute<X>(result: Aventus.Asyncable<ApplicationQueryFctResult<X>>, from: Application): Promise<X | undefined>;
        execute<X>(result: Aventus.Asyncable<ApplicationQueryFctResult<X>>, from?: Aventus.WebComponent): Promise<ApplicationQueryFctResult<X>>;
        refresh(key: Extract<keyof T, string>): void
        validateAndExecute<X>(result: Aventus.Asyncable<ApplicationQueryFctResult<X>>, from: Application): Promise<X | undefined>;
    }
    type FormDataInternal<T extends BodyJSON> = {
        [K in keyof T]: Required<FormPart<T[K]>>
    };

    export type VirtualForm<T extends BodyJSON> = FormDataInternal<T> & InternalVirtualFormType<T>;


    @Internal()
    export class InternalVirtualForm<T extends BodyJSON> implements InternalVirtualFormType<T> {

        private __config: FormDataInternal<T>;

        @Internal()
        public constructor(config: FormData<T>) {
            for(let name in config) {
                if(!config[name].elements) {
                    config[name].elements = [];
                }
                if(!config[name].validate) {
                    config[name].validate = () => true;
                }
            }
            this.__config = config as FormDataInternal<T>;

            for(let key in config) {
                this.registerKey(key);
            }
        }

        public async validateAndExecute<X>(result: Aventus.Asyncable<ApplicationQueryFctResult<X>>, application: Application): Promise<X | undefined> {
            const validationResult = await this.validate(application);
            if(validationResult) {
                return await this.execute(result, application);
            }
            return undefined;
        }

        public validate(from: Application): Promise<boolean>;
        public validate(from?: Aventus.WebComponent | undefined): Promise<boolean | string[]>;

        public async validate(from?: Application | Aventus.WebComponent | undefined): Promise<boolean | string[]> {
            let proms: Promise<boolean>[] = [];
            let promsCustom: Promise<FormValidateResult>[] = [];
            const namesCustom: string[] = [];
            const resultErrors: string[] = [];
            for(let name in this.__config) {
                const elements = this.__config[name].elements;
                if(!elements || elements.length == 0) {
                    const result = this.__config[name].validate(FormElement.getValue(this.__config[name]));
                    if(result instanceof Promise) {
                        promsCustom.push(result);
                        namesCustom.push(name);
                    }
                    else if(result !== undefined && result !== true && result !== "") {
                        if(result === false) {
                            resultErrors.push("Le champs " + name + " n'est pas valide");
                        }
                        resultErrors.push(result + "");
                    }
                }
                else {
                    for(let element of this.__config[name].elements) {
                        proms.push(element.validate());
                    }
                }
            }

            const result2 = await Promise.all(promsCustom);
            for(let i = 0; i < result2.length; i++) {
                const resultTemp = result2[i];
                if(resultTemp !== undefined && resultTemp !== true && resultTemp !== "") {
                    if(resultTemp === false) {
                        resultErrors.push("Le champs " + namesCustom[i] + " n'est pas valide");
                    }
                    resultErrors.push(resultTemp + "");
                }
            }


            if(resultErrors.length > 0) {
                if(from) {

                    let application = from instanceof Application ? from : from.findParentByType(Application);
                    await application?.alert({
                        title: "Erreur de validation",
                        description: resultErrors.join("<br>")
                    });
                    return false;
                }
                return resultErrors;
            }

            const result = await Promise.all(proms);
            for(let resultTemp of result) {
                if(!resultTemp) return false;
            }


            return true;
        }


        public execute<X>(query: Aventus.Asyncable<ApplicationQueryFctResult<X>>, from: Application): Promise<X | undefined>;
        public execute<X>(query: Aventus.Asyncable<ApplicationQueryFctResult<X>>, from?: Aventus.WebComponent | undefined): Promise<ApplicationQueryFctResult<X>>;
        public async execute<X>(query: Aventus.Asyncable<ApplicationQueryFctResult<X>>, from?: Application | Aventus.WebComponent): Promise<ApplicationQueryFctResult<X> | Awaited<X> | undefined> {
            let queryResult = await Aventus.Async(query);

            if(queryResult.errors.length > 0) {
                let noPrintErrors: Aventus.GenericError[] = [];
                for(let error of queryResult.errors) {
                    if(
                        error instanceof AventusSharp.Data.DataError &&
                        error.code == AventusSharp.Data.DataErrorCode.ValidationError &&
                        error.details.length > 0 &&
                        error.details[0] instanceof AventusSharp.Data.FieldErrorInfo
                    ) {
                        let fieldInfo = error.details[0];
                        if(this.addFieldError(fieldInfo.Name, error.message)) {
                            continue;
                        }
                    }

                    noPrintErrors.push(error);
                }
                queryResult.errors = noPrintErrors;
            }

            if(from) {
                let application = from instanceof Application ? from : from.findParentByType(Application);
                if(application) {
                    return await application.parseErrors(queryResult);
                }
            }
            return queryResult;
        }

        private registerKey(key: Extract<keyof T, string>) {
            Object.defineProperty(this, key, {
                get: () => this.__config[key],
                set: (value) => this.__config[key] = value,
                enumerable: true
            });
        }

        public getData(): T {
            let result: any = {};
            for(let name in this.__config) {
                result[name] = FormElement.getValue(this.__config[name]);
            }

            return result as T;
        }

        public refresh(key: Extract<keyof T, string>): void {
            const config = this.__config[key];
            for(let element of config.elements) {
                element.value = FormElement.getValue(config);
            }
        }

        public addFieldError(name: keyof T, error: string): boolean {
            if(this.__config[name]?.elements.length > 0) {
                for(let el of this.__config[name].elements) {
                    el.errors.push(error);
                }
                return true;
            }
            return false;
        }
    }
}