import { TableRowHeader } from "./rows/TableRowHeader/TableRowHeader.wcl.avt";
import { TableCell } from "./cells/TableCell/TableCell.wcl.avt";
import { TableRow } from "./rows/TableRow/TableRow.wcl.avt";
import { TableCellBoolean } from "./cells/TableCellBoolean.wc.avt";
import { TableCellString } from "./cells/TableCellString.wc.avt";
import { TableCellPicture } from "./cells/TableCellPicture.wc.avt";
import { TableCellNumber } from "./cells/TableCellNumber.wc.avt";
import { TableCellDate } from "./cells/TableCellDate.wc.avt";
import { TableCellCheckbox } from "./cells/TableCellCheckbox/TableCellCheckbox.wcl.avt";
import type { Scrollable } from "../Scrollable/Scrollable.wcl.avt";
import { TableCellHeader } from "./cells/TableCellHeader/TableCellHeader.wcl.avt";

namespace Components {
    export type TableCellType = 'number' | 'string' | 'date' | 'boolean' | 'custom' | 'picture';
    export type TableSchemaCellContent<T> = (data: T, cell: TableCell<any, T>) => (void | string | undefined);
    export type TableSchemaCellCst<T> = new () => TableCell<any, T>;
    export type TableSchemaCell<T> = TableSchemaCellCst<T>;
    export type TableSchema<T> = {
        displayName: string,
        name?: string,
        type: TableCellType,
        cell?: TableSchemaCell<T>;
        cellContent?: TableSchemaCellContent<T>;
        cellHeader?: new () => TableCell<any, any>;
        width?: number;
        minWidth?: number;
        sortable?: boolean;
    };
    export type TableOptions<T> = {
        schema: TableSchema<T>[];
        selectable: boolean;
        row: new () => TableRow<T>;
        header: new () => TableRowHeader<T>;
        sortable: boolean;
        title: string,
        globalSearch: boolean,
        showFooter?: boolean;
        items_per_page?: number,
        /** Delay before the loading animation show. If the loading take less than this number no animation is shown */
        timeoutBeforeLoading?: number,
        /** Minimum amount of time that the loading show must be displayed. */
        minTimeoutLoading?: number,
    };

    export type Key<T> = keyof T;

    export type FilterAction<T> = (value: T[Key<T>]) => boolean;
    export type FilterDataAction<T> = (value: T) => boolean;
    export type SortColumns = { [key: string]: 'asc' | 'desc'; };

    export abstract class Table<T, U extends TableOptions<T> = TableOptions<T>> extends Aventus.WebComponent implements Aventus.DefaultComponent {

        //#region static

        //#endregion


        //#region props
        @Attribute()
        public col_resize!: boolean;
        @Property()
        public auto_hide_scroll!: boolean;
        @Property((target: Table<T>) => {
            target.updateGrid();
        })
        protected grid!: boolean;
        @Property((target: Table<T>) => {
            target.renderPage();
            if(target.items_per_page > 0 && target.options.showFooter === undefined) {
                target.showFooter = true;
            }
        })
        public items_per_page: number = 0;
        /**
         * Define the size when the table must switch to grid
         */
        @Attribute()
        public grid_breakpoint!: number;

        @Attribute()
        private first_page!: boolean;

        @Attribute()
        private last_page!: boolean;

        @Attribute()
        private loading!: boolean;
        //#endregion


        //#region variables
        @ViewElement()
        protected headerContainer!: Scrollable;
        @ViewElement()
        protected bodyContainer!: Scrollable;
        @ViewElement()
        protected styleWrapper!: HTMLDivElement;

        @Watch()
        protected tableTitle: string = "";
        @Watch()
        protected showSearch: boolean = false;
        @Watch()
        protected showHeader: boolean = false;
        @Watch()
        protected showFooter: boolean = false;


        @Watch((target: Table<T>, action: Aventus.WatchAction, path: string, value: any) => {
            target.render();
        })
        public displayedData?: T[];

        @Watch((target: Table<T>, action: Aventus.WatchAction, path: string, value: any) => {
            target.filterData();
        })
        public data?: T[];
        protected options: U;
        protected filters: { [key: string]: FilterAction<T>[]; } = {};
        protected dataFilters: FilterDataAction<T>[] = [];
        protected sortColumns: SortColumns = {};
        protected globalSearchTxt?: string;
        protected rows: Map<T, TableRow<T>> = new Map();
        protected hadGlobalSearch: boolean = false;
        protected isFirstRender: boolean = true;

        @Watch((target: Table<T>) => {
            target.correctPage();
        })
        public currentPage: number = 0;
        @Watch()
        protected nbItems: number = 0;

        protected header!: TableRowHeader<T>;
        protected rowsSelected: TableRow<T>[] = [];
        protected rowsFiltered: TableRow<T>[] = [];
        protected rowsDisplayed: TableRow<T>[] = [];
        protected resizeObserver!: Aventus.ResizeObserver;
        protected mustForceRender: boolean = false;

        protected errorsTxtItemPerPage: {
            notNumber: string;
            lowerThanMin: string,
            biggerThanMax: string;
        } = {
                notNumber: '',
                lowerThanMin: '',
                biggerThanMax: '',
            };

        public getSelectedData(): T[] {
            const result: T[] = [];
            for(let row of this.rowsSelected) {
                result.push(row.data);
            }
            return result;
        }
        //#endregion


        //#region constructor
        constructor() {
            super();
            this.options = this.configure(this.defaultOptions());
            this.normalizeSchema();
            this.auto_hide_scroll = this.autoHideScroll();
            this.style.display = 'none';
        }
        //#endregion


        //#region methods
        //#region loading
        private showLoadingStart: Date | undefined;
        private showLoadingTimeout: number = 0;
        protected timeoutBeforeLoading: number = 200;
        protected minTimeoutLoading: number = 1000;
        public showLoading() {
            this.showLoadingTimeout = setTimeout(() => {
                this.showLoadingStart = new Date();
                this.loading = true;
            }, this.timeoutBeforeLoading);
        }
        public async hideLoading() {
            const minDelay = this.minTimeoutLoading;
            clearTimeout(this.showLoadingTimeout);
            if(this.showLoadingStart) {
                let now = new Date();
                let diffMs = now.getTime() - this.showLoadingStart.getTime();
                if(diffMs < minDelay) {
                    await Aventus.sleep(minDelay - diffMs);
                }
                this.showLoadingStart = undefined;
            }
            this.loading = false;
        }
        //#endregion

        protected autoHideScroll() {
            return true;
        }
        public selectRow(row?: TableRow<T>) {
            if(!row) return;
            if(!this.rowsSelected.includes(row)) {
                this.rowsSelected.push(row);
                this.onSelected();
                this.select.trigger([this.getSelectedData()]);
            }
        }
        public unselectRow(row?: TableRow<T>) {
            if(!row) return;
            let index = this.rowsSelected.indexOf(row);
            if(index != -1) {
                this.rowsSelected.splice(index, 1);
                this.onSelected();
                this.select.trigger([this.getSelectedData()]);
            }
        }
        public unselectAllRows() {
            this.rowsSelected = [];
            this.onSelected();
            this.select.trigger([[]]);
        }

        public select: Aventus.Callback<(data: T[]) => void> = new Aventus.Callback();
        /**
         * Trigger when a row is selected
         */
        protected onSelected() {

        }

        protected syncScroll() {
            this.headerContainer?.onScrollChange.add((x, y) => {
                if(this.bodyContainer?.x != x) {
                    this.bodyContainer?.scrollX(x);
                }
            });
            this.bodyContainer?.onScrollChange.add((x, y) => {
                if(this.headerContainer?.x != x) {
                    this.headerContainer?.scrollX(x);
                }
            });
        }

        protected normalizeSchemaCell(cellConfig: TableSchema<T>): void {
            if(!cellConfig.cell) {
                if(cellConfig.type == "boolean") cellConfig.cell = TableCellBoolean;
                else if(cellConfig.type == "date") cellConfig.cell = TableCellDate;
                else if(cellConfig.type == "number") cellConfig.cell = TableCellNumber;
                else if(cellConfig.type == "picture") cellConfig.cell = TableCellPicture;
                else if(cellConfig.type == "string") cellConfig.cell = TableCellString;
                else if(cellConfig.type == "custom") cellConfig.cell = TableCellString;
            }
        }
        protected normalizeSchema(): void {
            for(let cellConfig of this.options.schema) {
                this.normalizeSchemaCell(cellConfig);
            }

            if(this.options.title || this.options.globalSearch) {
                this.showHeader = true;
                this.tableTitle = this.options.title;
                this.showSearch = this.options.globalSearch;
            }

            if(this.options.showFooter) {
                this.showFooter = true;
            }

            if(this.options.items_per_page && this.options.items_per_page > 0) {
                this.items_per_page = this.options.items_per_page;
            }

            if(this.options.selectable) {
                this.options.schema.splice(0, 0, {
                    displayName: "",
                    name: "",
                    type: "custom",
                    cell: TableCellCheckbox,
                    width: 50,
                    sortable: false
                });
            }

            if(this.options.timeoutBeforeLoading !== undefined) {
                this.timeoutBeforeLoading = this.options.timeoutBeforeLoading
            }

            if(this.options.minTimeoutLoading !== undefined) {
                this.minTimeoutLoading = this.options.minTimeoutLoading
            }
        }
        protected defaultOptions(): TableOptions<T> {
            return {
                schema: [],
                selectable: false,
                header: TableRowHeader,
                row: TableRow,
                sortable: true,
                title: '',
                globalSearch: false,
            };
        }
        /**
         * Define the schema needed for the table
         */
        protected abstract configure(options: TableOptions<T>): U;

        public setColWidth(width: number, i: number) {
            this.styleWrapper?.style.setProperty("--_table-cell-width-" + (i + 1), width + "px");
            this.styleWrapper?.style.setProperty("--_table-cell-weight-" + (i + 1), "0");
        }
        public setColMinWidth(width: number, i: number) {
            this.styleWrapper?.style.setProperty("--_table-cell-min-width-" + (i + 1), width + "px");
        }
        protected sortData(data: T[]): T[] {
            return data;
        }

        public setSortColumn(column: string, order: 'asc' | 'desc' | undefined) {
            let cell = this.header.cells[column];
            if(!(cell instanceof TableCellHeader)) return;

            cell.sort_direction = order;

            if(order === undefined) {
                delete this.sortColumns[column];
            }
            else {
                this.sortColumns[column] = order;
            }
            this.render(order !== undefined);
        }

        protected filterData(forceRender: boolean = false) {
            let result: T[] = [];
            let oldData = Array.from(this.rows.keys());
            if(this.data) {
                for(let item of this.data) {
                    let isOk = true;
                    // remove old data to avoid delete it
                    let index = oldData.indexOf(item);
                    if(index != -1) {
                        oldData.splice(index, 1);
                    }
                    // apply filters
                    for(let name in this.filters) {
                        let value = item[name];
                        let filters = this.filters[name];
                        for(let filter of filters) {
                            if(!filter(value)) {
                                isOk = false;
                                break;
                            }
                        }
                    }
                    for(let dataFilter of this.dataFilters) {
                        if(!dataFilter(item)) {
                            isOk = false;
                            break;
                        }
                    }
                    if(isOk) {
                        result.push(item);
                    }
                }
            }
            // delete old rows
            for(let oldItem of oldData) {
                this.rows.get(oldItem)?.remove();
                this.rows.delete(oldItem);
            }
            result = this.sortData(result);
            if(forceRender) {
                this.mustForceRender = true;
            }
            this.displayedData = result;
            if(this.mustForceRender) {
                this.render();
            }
        }

        protected firstRender() {
            if(this.isFirstRender) {
                this.isFirstRender = false;
                for(let i = 0; i < this.options.schema.length; i++) {
                    const width = this.options.schema[i].width;
                    if(width) {
                        this.setColWidth(width, i);
                    }

                    const minWidth = this.options.schema[i].minWidth;
                    if(minWidth) {
                        this.setColMinWidth(minWidth, i);
                    }
                }
                let nbCol = this.options.schema.length ? this.options.schema.length : 1;
                this.styleWrapper?.style.setProperty("--_table-nb-column", nbCol + "");

                this.header = new this.options.header();
                this.header.table = this;
                this.header.init(this.options);

                this.headerContainer.innerHTML = "";
                this.headerContainer.appendChild(this.header);
            }
        }
        protected render(onlySort: boolean = false) {
            this.mustForceRender = false;
            if(!this.headerContainer || !this.bodyContainer) {
                return;
            }
            let isFirst = this.isFirstRender;
            this.firstRender();

            this.hadGlobalSearch = false;


            if(!onlySort) {
                let newRowsFiltered: TableRow<T>[] = [];
                if(this.displayedData) {
                    for(let item of this.displayedData) {

                        let rowItem = this.rows.get(item);
                        if(!rowItem) {
                            let row = new this.options.row();
                            row.table = this;
                            row.grid = this.grid;
                            row.init(this.options, item);
                            this.rows.set(item, row);
                            rowItem = row;
                        }

                        let search = this.globalSearchTxt?.trim().toLowerCase();
                        if(search) {
                            if(!rowItem.globalSearch(search)) {
                                continue;
                            }
                        }

                        newRowsFiltered.push(rowItem);
                    }
                }
                this.rowsFiltered = newRowsFiltered;
            }

            for(let column in this.sortColumns) {
                this.rowsFiltered.sort((a, b) => a.sort(b, column, this.sortColumns[column]));
            }

            this.nbItems = this.rowsFiltered.length;
            this.renderPage();
            if(isFirst) {
                this.style.display = '';
            }
        }

        protected renderPage() {
            this.correctPage();

            let oldRowsDisplayed = [...this.rowsDisplayed];
            let rowsDisplayed = this.items_per_page ? this.rowsFiltered.slice(this.items_per_page * this.currentPage, this.items_per_page * (this.currentPage + 1)) : [...this.rowsFiltered];

            for(let oldRowDisplayed of oldRowsDisplayed) {
                // remove from DOM but don't destroy
                oldRowDisplayed.parentElement?.removeChild(oldRowDisplayed);
            }
            for(let row of rowsDisplayed) {
                this.bodyContainer.appendChild(row);
            }

            this.rowsDisplayed = rowsDisplayed;
            this.hideLoading();
        }

        protected locationInfo() {
            const nbItems = this.nbItems;
            const currentPage = this.currentPage;
            const start = this.items_per_page == 0 ? 0 : Math.min(this.items_per_page * currentPage + 1, nbItems);
            const end = this.items_per_page == 0 ? nbItems : Math.min(this.items_per_page * (currentPage + 1), nbItems);
            return `${start}-${end} sur ${nbItems}`;
        }


        protected correctPage() {
            let maxPage = this.items_per_page == 0 ? 0 : Math.floor(this.nbItems / this.items_per_page);
            if(this.currentPage < 0) {
                this.currentPage = 0;
            }
            else if(this.currentPage > maxPage) {
                this.currentPage = maxPage;
            }

            this.first_page = this.currentPage == 0;
            this.last_page = this.currentPage == maxPage;
        }

        public previousPage() {
            this.currentPage--;
            this.renderPage();
        }
        public firstPage() {
            this.currentPage = 0;
            this.renderPage();
        }
        public nextPage() {
            this.currentPage++;
            this.renderPage();
        }
        public lastPage() {
            this.currentPage = this.items_per_page == 0 ? 0 : Math.floor(this.nbItems / this.items_per_page);
            this.renderPage();
        }

        public globalFilter(txt: string) {
            this.globalSearchTxt = txt;
            this.currentPage = 0;
            this.render();
        }
        /**
         * Add filter on the data key
         * return true if the element can be displayed
         */
        public addFilter<U extends keyof T>(name: U, action: (value: T[U]) => boolean, reload: boolean = true) {
            let nameTxt = name as string;
            if(!this.filters[nameTxt]) {
                this.filters[nameTxt] = [];
            }
            else if(this.filters[nameTxt].includes(action)) {
                return;
            }
            this.filters[nameTxt].push(action);
            if(reload && this.isReady)
                this.filterData();
        }
        public removeFilter<U extends keyof T>(name: U, action: (value: T[U]) => boolean, reload: boolean = true) {
            let nameTxt = name as string;
            if(this.filters[nameTxt]) {
                let index = this.filters[nameTxt].indexOf(action);
                if(index != -1) {
                    this.filters[nameTxt].splice(index, 1);
                }
            }
            if(reload && this.isReady)
                this.filterData();
        }
        /**
         * Add filter on the data
         * return true if the element can be displayed
         */
        public addCustomFilter(action: (value: T) => boolean, reload: boolean = true) {
            if(this.dataFilters.includes(action)) {
                return;
            }
            this.dataFilters.push(action);
            if(reload && this.isReady)
                this.filterData();
        }
        public removeCustomFilter(action: (value: T) => boolean, reload: boolean = true) {
            let index = this.dataFilters.indexOf(action);
            if(index != -1) {
                this.dataFilters.splice(index, 1);
            }
            if(reload && this.isReady)
                this.filterData();
        }
        protected registerObserver() {
            this.resizeObserver = new Aventus.ResizeObserver(() => {
                this.grid = (this.grid_breakpoint != undefined && this.offsetWidth <= this.grid_breakpoint);
            });
            this.resizeObserver.observe(this);
        }

        protected updateGrid() {
            for(const [item, row] of this.rows) {
                row.grid = this.grid;
            }
        }

        protected override postCreation(): void {
            this.syncScroll();
            this.registerObserver();
            this.render();
        }

        protected override postDestruction(): void {
            super.postDestruction();
            this.resizeObserver.disconnect();
            for(let [item, row] of this.rows) {
                row.remove();
            }
        }
        //#endregion
    }
}