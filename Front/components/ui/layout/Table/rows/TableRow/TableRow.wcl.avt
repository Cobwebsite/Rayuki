import type { TableCell } from "../../cells/TableCell/TableCell.wcl.avt";
import { TableCellString } from "../../cells/TableCellString.wc.avt";
import type { SortColumns, Table, TableOptions, TableSchema, TableSchemaCell, TableSchemaCellCst } from "../../Table.wcl.avt";

namespace Components {
    @Storybook({
        export: 'public',
        group: 'Components/Layout/Table'
    })
    export class TableRow<T> extends Aventus.WebComponent implements Aventus.DefaultComponent {

        //#region static

        //#endregion


        //#region props
        @Property((target: TableRow<T>) => {
            target.updateGrid();
        })
        public grid!: boolean;

        @Attribute()
        private custom_grid!: boolean;
        //#endregion


        //#region variables
        @ViewElement()
        protected rowContentEl!: HTMLDivElement;

        public table?: Table<T>;

        protected _data!: T;

        public get data(): T {
            return this._data;
        }

        protected cells: TableCell<any, T>[] = [];
        protected options!: TableOptions<T>;
        //#endregion


        //#region constructor
        public constructor() {
            super();
            this.custom_grid = this.customGridTemplate();
        }
        //#endregion


        //#region methods
        protected customGridTemplate(): boolean {
            return false;
        }

        protected getCell(cellConfig: TableSchema<T>): TableSchemaCell<T> {
            return cellConfig.cell ?? TableCellString;
        }

        protected async addCellOption(cell: TableCell<any>, cellConfig: TableSchema<T>, data: T): Promise<void> {

        }

        public async init(options: TableOptions<T>, data: T) {
            this.options = options;
            this._data = data;
            let i = 0;
            this.cells = [];
            for(let cellConfig of options.schema) {
                let cellInfo = this.getCell(cellConfig);
                let cell: TableCell<any, T>;
                let cst = cellInfo as TableSchemaCellCst<T>;
                cell = new cst();

                cell.index = i;
                cell.row = this;
                cell.data = data;
                cell.label = cellConfig.name;
                cell.grid = this.grid;
                cell.cellConfig = cellConfig;
                await this.addCellOption(cell, cellConfig, data);
                await this.setCellContent(cell, cellConfig, data);
                this.rowContentEl.appendChild(cell);
                this.cells.push(cell);
                i++;
            }
        }

        protected async setCellContent(cell: TableCell<any, T>, cellConfig: TableSchema<T>, data: T): Promise<void> {
            if(cellConfig.cellContent) {
                const result = await cellConfig.cellContent(data, cell);
                if(result) {
                    await cell.setContent(result, data);
                }
            }
            else {
                const v = cellConfig.name ? Aventus.getValueFromObject(cellConfig.name, data) : undefined;
                await cell.setContent(v, data);
            }
        }

        public globalSearch(search: string): boolean {
            for(let cell of this.cells) {
                if(cell.globalSearch(search)) {
                    return true;
                }
            }
            return false;
        }

        public sort(row: TableRow<T>, column: string, order: 'asc' | 'desc'): number {
            let cell = this.cells.find(c => c.cellConfig.displayName == column || c.cellConfig.name == column);
            let cellRow = row.cells.find(c => c.cellConfig.displayName == column || c.cellConfig.name == column);

            if(!cell || !cellRow) return 0;

            let result = cell.sortAsc(cellRow);
            if(order == 'desc')
                result *= -1;
            return result;
        }

        protected updateGrid() {
            for(let cell of this.cells) {
                cell.grid = this.grid;
            }
        }

        protected override postDestruction(): void {
            super.postDestruction();
            for(let cell of this.cells) {
                cell.remove();
            }
        }
        //#endregion
    }
}